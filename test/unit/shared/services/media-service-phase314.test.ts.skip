/**
 * @fileoverview MediaService Phase 314-Extended 테스트
 * @description validateAvailability() + simulateMediaFetch() 메서드 테스트
 */

import { describe, it, expect, beforeEach } from 'vitest';
import { MediaService } from '@/shared/services/media-service.js';
import type {
  MediaAvailabilityResult,
  SimulatedMediaFetchResult,
} from '@/shared/services/media-service.js';

describe('MediaService - Phase 314-Extended', () => {
  let mediaService: MediaService;
  let httpService: HttpRequestService;

  beforeEach(() => {
    mediaService = new MediaService();
    httpService = HttpRequestService.getInstance();
  });

  // ====================================
  // validateAvailability() 테스트
  // ====================================

  describe('validateAvailability()', () => {
    it('should return availability result with correct structure', async () => {
      const result = await mediaService.validateAvailability();

      expect(result).toHaveProperty('available');
      expect(result).toHaveProperty('environment');
      expect(result).toHaveProperty('message');
      expect(result).toHaveProperty('canSimulate');
      expect(result).toHaveProperty('dependencies');
      expect(typeof result.available).toBe('boolean');
      expect(typeof result.message).toBe('string');
    });

    it('should check HttpRequestService dependency', async () => {
      const result = await mediaService.validateAvailability();

      expect(result.dependencies).toHaveProperty('httpService');
      expect(result.dependencies.httpService).toHaveProperty('available');
      expect(typeof result.dependencies.httpService.available).toBe('boolean');
    });

    it('should include environment information', async () => {
      const result = await mediaService.validateAvailability();

      expect(['browser', 'test', 'node', 'unknown']).toContain(result.environment);
      const hasEmoji = result.message.includes('✅') || result.message.includes('⚠️');
      expect(hasEmoji).toBe(true);
    });

    it('should indicate simulation capability', async () => {
      const result = await mediaService.validateAvailability();

      expect(typeof result.canSimulate).toBe('boolean');
    });

    it('should provide reason for dependency status', async () => {
      const result = await mediaService.validateAvailability();

      if (!result.dependencies.httpService.available) {
        expect(result.dependencies.httpService).toHaveProperty('reason');
        expect(typeof result.dependencies.httpService.reason).toBe('string');
      }
    });
  });

  // ====================================
  // simulateMediaFetch() 테스트
  // ====================================

  describe('simulateMediaFetch()', () => {
    it('should simulate single media item fetch', async () => {
      const mediaItems = [
        {
          url: 'https://pbs.twimg.com/media/test1.jpg',
          type: 'photo',
        } as unknown as Parameters<typeof mediaService.simulateMediaFetch>[0][0],
      ];

      const result = await mediaService.simulateMediaFetch(mediaItems);

      expect(result.success).toBe(true);
      expect(result.itemsProcessed).toBe(1);
      expect(result.itemsSimulated).toBe(1);
      expect(result.simulatedData).toHaveLength(1);
    });

    it('should simulate multiple media items', async () => {
      const mediaItems = [
        {
          url: 'https://pbs.twimg.com/media/test1.jpg',
          type: 'photo',
        },
        {
          url: 'https://video.twimg.com/test2.mp4',
          type: 'video',
        },
        {
          url: 'https://pbs.twimg.com/media/test3.jpg',
          type: 'photo',
        },
      ] as unknown as Parameters<typeof mediaService.simulateMediaFetch>[0];

      const result = await mediaService.simulateMediaFetch(mediaItems);

      expect(result.success).toBe(true);
      expect(result.itemsProcessed).toBe(3);
      expect(result.itemsSimulated).toBe(3);
      expect(result.simulatedData).toHaveLength(3);
    });

    it('should include correct mime types in simulated data', async () => {
      const mediaItems = [
        { url: 'https://pbs.twimg.com/media/test1.jpg', type: 'photo' },
        { url: 'https://video.twimg.com/test2.mp4', type: 'video' },
        { url: 'https://pbs.twimg.com/media/test3.gif', type: 'animated_gif' },
      ] as unknown as Parameters<typeof mediaService.simulateMediaFetch>[0];

      const result = await mediaService.simulateMediaFetch(mediaItems);

      expect(result.simulatedData[0].mimeType).toBe('image/jpeg');
      expect(result.simulatedData[1].mimeType).toBe('video/mp4');
      expect(result.simulatedData[2].mimeType).toBe('video/mp4');
    });

    it('should include timestamp in simulated data', async () => {
      const mediaItems = [
        { url: 'https://pbs.twimg.com/media/test1.jpg', type: 'photo' },
      ] as unknown as Parameters<typeof mediaService.simulateMediaFetch>[0];

      const beforeTime = Date.now();
      const result = await mediaService.simulateMediaFetch(mediaItems);
      const afterTime = Date.now();

      expect(result.simulatedData[0]).toHaveProperty('timestamp');
      expect(result.simulatedData[0].timestamp).toBeGreaterThanOrEqual(beforeTime);
      expect(result.simulatedData[0].timestamp).toBeLessThanOrEqual(afterTime);
    });

    it('should include URL in simulated data', async () => {
      const testUrl = 'https://pbs.twimg.com/media/test.jpg';
      const mediaItems = [{ url: testUrl, type: 'photo' }] as unknown as Parameters<
        typeof mediaService.simulateMediaFetch
      >[0];

      const result = await mediaService.simulateMediaFetch(mediaItems);

      expect(result.simulatedData[0].url).toBe(testUrl);
    });

    it('should handle empty media array', async () => {
      const mediaItems: typeof mediaService.simulateMediaFetch extends (
        arg: infer T,
        ...args: unknown[]
      ) => unknown
        ? T
        : never = [] as never;

      const result = await mediaService.simulateMediaFetch(mediaItems);

      expect(result.itemsProcessed).toBe(0);
      expect(result.itemsSimulated).toBe(0);
      expect(result.simulatedData).toHaveLength(0);
    });

    it('should handle AbortSignal', async () => {
      const controller = new globalThis.AbortController();

      const mediaItems = [
        { url: 'https://pbs.twimg.com/media/test1.jpg', type: 'photo' },
      ] as unknown as Parameters<typeof mediaService.simulateMediaFetch>[0];

      controller.abort();

      const result = await mediaService.simulateMediaFetch(mediaItems, {
        signal: controller.signal,
      });

      expect(result.success).toBe(false);
      expect(result.error).toBe('Aborted');
      expect(result.itemsSimulated).toBe(0);
    });

    it('should provide user-friendly message', async () => {
      const mediaItems = [
        { url: 'https://pbs.twimg.com/media/test1.jpg', type: 'photo' },
        { url: 'https://video.twimg.com/test2.mp4', type: 'video' },
      ] as unknown as Parameters<typeof mediaService.simulateMediaFetch>[0];

      const result = await mediaService.simulateMediaFetch(mediaItems);

      expect(result.message).toContain('✅');
      expect(result.message).toContain('2/2');
      expect(result.message).toContain('미디어 아이템');
      expect(result.message).toContain('완료');
    });
  });

  // ====================================
  // 통합 테스트
  // ====================================

  describe('Integration', () => {
    it('should validate availability before simulating', async () => {
      const availability = await mediaService.validateAvailability();

      expect(availability).toBeDefined();
      expect(availability.dependencies.httpService).toBeDefined();

      if (availability.canSimulate) {
        const mediaItems = [
          { url: 'https://pbs.twimg.com/media/test.jpg', type: 'photo' },
        ] as unknown as Parameters<typeof mediaService.simulateMediaFetch>[0];

        const result = await mediaService.simulateMediaFetch(mediaItems);

        expect(result).toBeDefined();
        expect(result.itemsSimulated).toBeGreaterThanOrEqual(0);
      }
    });

    it('should maintain consistency across availability checks', async () => {
      const result1 = await mediaService.validateAvailability();
      const result2 = await mediaService.validateAvailability();

      expect(result1.available).toBe(result2.available);
      expect(result1.environment).toBe(result2.environment);
    });

    it('should handle mixed media types in sequence', async () => {
      const mediaItems = [
        { url: 'https://pbs.twimg.com/media/test1.jpg', type: 'photo' },
        { url: 'https://video.twimg.com/test2.mp4', type: 'video' },
        { url: 'https://pbs.twimg.com/media/test3.gif', type: 'animated_gif' },
        { url: 'https://pbs.twimg.com/media/test4.jpg', type: 'photo' },
      ] as unknown as Parameters<typeof mediaService.simulateMediaFetch>[0];

      const result = await mediaService.simulateMediaFetch(mediaItems);

      expect(result.itemsProcessed).toBe(4);
      expect(result.itemsSimulated).toBe(4);
      expect(result.simulatedData).toHaveLength(4);

      // 각 아이템이 올바른 타입을 가져야 함
      result.simulatedData.forEach((item, index) => {
        expect(item).toHaveProperty('url');
        expect(item).toHaveProperty('mimeType');
        expect(item).toHaveProperty('timestamp');
        expect(typeof item.url).toBe('string');
        expect(typeof item.mimeType).toBe('string');
        expect(typeof item.timestamp).toBe('number');
      });
    });
  });

  // ====================================
  // 에러 처리
  // ====================================

  describe('Error Handling', () => {
    it('should handle invalid media type gracefully', async () => {
      const mediaItems = [
        { url: 'https://pbs.twimg.com/media/test.jpg', type: 'unknown' },
      ] as unknown as Parameters<typeof mediaService.simulateMediaFetch>[0];

      const result = await mediaService.simulateMediaFetch(mediaItems);

      expect(result.success).toBe(true);
      expect(result.simulatedData[0].mimeType).toBe('application/octet-stream');
    });

    it('should return error result on failure', async () => {
      const mediaItems = null as never;

      try {
        await mediaService.simulateMediaFetch(mediaItems);
      } catch {
        // 예상된 에러
      }
    });

    it('should provide descriptive error messages', async () => {
      const result = await mediaService.validateAvailability();

      if (!result.available) {
        const hasErrorEmoji = result.message.includes('⚠️') || result.message.includes('❌');
        expect(hasErrorEmoji).toBe(true);
        expect(result.message.length).toBeGreaterThan(0);
      }
    });
  });
});
