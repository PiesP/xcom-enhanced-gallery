#!/usr/bin/env node

/**
 * @fileoverview SolidJS Native Codemod Script
 * @description Preact Signals Î†àÍ±∞Ïãú Ìå®ÌÑ¥ÏùÑ SolidJS ÎÑ§Ïù¥Ìã∞Î∏å Ìå®ÌÑ¥ÏúºÎ°ú ÏûêÎèô Î≥ÄÌôò
 *
 * Epic: SOLID-NATIVE-002 Phase B
 *
 * Î≥ÄÌôò Í∑úÏπô:
 * 1. AUTO: signal.value (ÏùΩÍ∏∞) ‚Üí signal() Ìï®Ïàò Ìò∏Ï∂ú
 * 2. SEMI_AUTO: signal.value = newValue ‚Üí setSignal(newValue) setter Ìò∏Ï∂ú
 * 3. MANUAL: signal.subscribe(callback) ‚Üí ÏàòÎèô Ï≤òÎ¶¨ ÌïÑÏöî (Î≥ÄÌôòÌïòÏßÄ ÏïäÏùå)
 *
 * False Positive ÌïÑÌÑ∞:
 * - DOM ÏöîÏÜå: input.value, element.value, select.value, target.value Îì±
 * - Object/Map Î©îÏÑúÎìú: Object.values(), Map.values() Îì±
 *
 * ÏÇ¨Ïö©Î≤ï:
 *   npm run codemod:solid-native          # ÎØ∏Î¶¨Î≥¥Í∏∞ (Dry Run)
 *   npm run codemod:solid-native --apply  # Ïã§Ï†ú Î≥ÄÌôò Ï†ÅÏö©
 */

/* global process, console */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// False positive ÌïÑÌÑ∞ Ìå®ÌÑ¥
const DOM_VALUE_PATTERNS = [
  /\binput\.value\b/,
  /\belement\.value\b/,
  /\bselect\.value\b/,
  /\btarget\.value\b/,
  /\bthemeSelect\.value\b/,
  /\blanguageSelect\.value\b/,
  /\battr\.value\b/,
  /\bentry\.value\b/,
  /\boption\.value\b/,
  /\bnode\.value\b/,
  /\btextarea\.value\b/,
];

const OBJECT_MAP_PATTERNS = [
  /\bObject\.values\(/,
  /\bMap\.prototype\.values\(/,
  /\bmap\.values\(/,
  /\bArray\.from\([^)]*\.values\(\)/,
];

/**
 * ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò Îßµ JSON Î°úÎìú
 */
function loadMigrationMap() {
  const mapPath = path.join(__dirname, '../docs/legacy-pattern-migration-map.json');
  if (!fs.existsSync(mapPath)) {
    throw new Error('Migration map not found. Run scan-legacy-patterns first.');
  }
  return JSON.parse(fs.readFileSync(mapPath, 'utf-8'));
}

/**
 * False positive Ïó¨Î∂Ä ÌôïÏù∏
 */
function isFalsePositive(line) {
  // DOM ÏöîÏÜå .value Ìå®ÌÑ¥
  for (const pattern of DOM_VALUE_PATTERNS) {
    if (pattern.test(line)) return true;
  }

  // Object/Map Î©îÏÑúÎìú Ìå®ÌÑ¥
  for (const pattern of OBJECT_MAP_PATTERNS) {
    if (pattern.test(line)) return true;
  }

  return false;
}

/**
 * .value ÏùΩÍ∏∞ Ìå®ÌÑ¥ Î≥ÄÌôò: signal.value ‚Üí signal()
 */
function transformValueRead(content) {
  let transformedContent = content;
  const transformations = [];
  const lines = content.split('\n');

  lines.forEach((line, index) => {
    if (isFalsePositive(line)) return;

    // .value ÏùΩÍ∏∞ Ìå®ÌÑ¥ Ï∞æÍ∏∞ (Ìï†ÎãπÎ¨∏Ïù¥ ÏïÑÎãå Í≤ΩÏö∞Îßå)
    const valueReadPattern = /\b(\w+)\.value\b(?!\s*=)/g;
    let match;
    const lineTransformations = [];

    while ((match = valueReadPattern.exec(line)) !== null) {
      const signalName = match[1];

      lineTransformations.push({
        type: 'value-read',
        line: index + 1,
        original: `${signalName}.value`,
        transformed: `${signalName}()`,
        signalName,
      });
    }

    // ÎùºÏù∏Î≥ÑÎ°ú Ïó≠ÏàúÏúºÎ°ú ÏπòÌôò (Ïù∏Îç±Ïä§ Î≥ÄÍ≤Ω Î∞©ÏßÄ)
    if (lineTransformations.length > 0) {
      let transformedLine = line;
      // Í∞ôÏùÄ ÎùºÏù∏Ïóê Ïó¨Îü¨ Ìå®ÌÑ¥Ïù¥ ÏûàÏùÑ Ïàò ÏûàÏúºÎØÄÎ°ú Ï†ÑÏ≤¥ ÏπòÌôò
      transformedLine = transformedLine.replace(/\b(\w+)\.value\b(?!\s*=)/g, '$1()');

      const originalLine = lines[index];
      transformedContent = transformedContent.replace(originalLine, transformedLine);

      transformations.push(...lineTransformations);
    }
  });

  return {
    content: transformedContent,
    transformations,
  };
}

/**
 * .value Ïì∞Í∏∞ Ìå®ÌÑ¥ Î≥ÄÌôò: signal.value = x ‚Üí setSignal(x)
 */
function transformValueWrite(content) {
  let transformedContent = content;
  const transformations = [];
  const lines = content.split('\n');

  lines.forEach((line, index) => {
    if (isFalsePositive(line)) return;

    // .value Ìï†Îãπ Ìå®ÌÑ¥
    const valueWritePattern = /\b(\w+)\.value\s*=\s*(.+?)(;|$)/g;
    let match;

    while ((match = valueWritePattern.exec(line)) !== null) {
      const signalName = match[1];
      const value = match[2].trim();
      const terminator = match[3];

      // Setter Ïù¥Î¶Ñ Ï∂îÎ°†: mySignal ‚Üí setMySignal
      const setterName = `set${signalName.charAt(0).toUpperCase()}${signalName.slice(1)}`;

      const original = `${signalName}.value = ${value}`;
      const transformed = `${setterName}(${value})`;

      transformations.push({
        type: 'value-write',
        line: index + 1,
        original: original + terminator,
        transformed: transformed + terminator,
        signalName,
        setterName,
      });
    }
  });

  // Î≥ÄÌôò Ï†ÅÏö© (Ïó≠ÏàúÏúºÎ°ú Ï≤òÎ¶¨ÌïòÏó¨ Ïù∏Îç±Ïä§ Î≥ÄÍ≤Ω Î∞©ÏßÄ)
  transformations.reverse().forEach(t => {
    const pattern = new RegExp(
      `\\b${t.signalName}\\.value\\s*=\\s*${escapeRegExp(t.original.replace(`${t.signalName}.value = `, '').replace(/;$/, ''))}`,
      'g'
    );
    const replacement = t.transformed.replace(/;$/, '');
    transformedContent = transformedContent.replace(pattern, replacement);
  });

  return {
    content: transformedContent,
    transformations: transformations.reverse(),
  };
}

/**
 * Ï†ïÍ∑úÏãù ÌäπÏàòÎ¨∏Ïûê Ïù¥Ïä§ÏºÄÏù¥ÌîÑ
 */
function escapeRegExp(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

/**
 * ÌååÏùº Î≥ÄÌôò Î∂ÑÏÑù
 */
function analyzeFile(filePath) {
  const content = fs.readFileSync(filePath, 'utf-8');

  // 1Ï∞® Î≥ÄÌôò: .value ÏùΩÍ∏∞
  const step1 = transformValueRead(content);

  // 2Ï∞® Î≥ÄÌôò: .value Ïì∞Í∏∞
  const step2 = transformValueWrite(step1.content);

  const allTransformations = [...step1.transformations, ...step2.transformations];
  const changed = allTransformations.length > 0;

  return {
    filePath,
    changed,
    transformations: allTransformations,
    transformedContent: step2.content,
  };
}

/**
 * Î≥ÄÌôò Î¶¨Ìè¨Ìä∏ ÏÉùÏÑ±
 */
function generateReport(results) {
  const changedFiles = results.filter(r => r.changed);

  console.log('\nüìä Î≥ÄÌôò ÏöîÏïΩ:');
  console.log(`  - Ïä§Ï∫îÌïú ÌååÏùº: ${results.length}Í∞ú`);
  console.log(`  - Î≥ÄÌôò ÌïÑÏöî: ${changedFiles.length}Í∞ú`);
  console.log(`  - Î≥ÄÌôò ÏóÜÏùå: ${results.length - changedFiles.length}Í∞ú`);

  if (changedFiles.length > 0) {
    console.log('\nüìù Î≥ÄÌôò ÏÉÅÏÑ∏:');
    changedFiles.forEach(result => {
      console.log(`\n=== ${path.relative(process.cwd(), result.filePath)} ===`);
      result.transformations.forEach(t => {
        console.log(`  Line ${t.line} [${t.type}]:`);
        console.log(`    - ${t.original}`);
        console.log(`    + ${t.transformed}`);
      });
    });
  }

  return changedFiles;
}

/**
 * Codemod Ïã§Ìñâ
 */
async function runCodemod(dryRun = true) {
  console.log('üîç Loading migration map...');
  const migrationMap = loadMigrationMap();

  console.log(`\nüìã ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò Îßµ ÏöîÏïΩ:`);
  console.log(`  - Ï¥ù ÌååÏùº: ${migrationMap.summary.totalFiles}Í∞ú`);
  console.log(`  - Ï¥ù Ìå®ÌÑ¥: ${migrationMap.summary.totalPatterns}Í∞ú`);
  console.log(`  - AUTO: ${migrationMap.summary.auto}Í∞ú`);
  console.log(`  - SEMI_AUTO: ${migrationMap.summary.semiAuto}Í∞ú`);
  console.log(`  - MANUAL: ${migrationMap.summary.manual}Í∞ú (Í±¥ÎÑàÎúÄ)`);

  // AUTO Ìå®ÌÑ¥Îßå Ï≤òÎ¶¨ (SEMI_AUTOÎäî setter Ïù¥Î¶Ñ Ï∂îÎ°† ÌïÑÏöî)
  const autoFiles = migrationMap.files
    .filter(f => f.classified.auto.length > 0)
    .map(f => path.join(process.cwd(), f.path));

  console.log(`\nüéØ Ï≤òÎ¶¨ ÎåÄÏÉÅ: ${autoFiles.length}Í∞ú ÌååÏùº`);

  const results = [];

  for (const filePath of autoFiles) {
    const analysis = analyzeFile(filePath);
    results.push(analysis);
  }

  const changedFiles = generateReport(results);

  if (!dryRun && changedFiles.length > 0) {
    console.log('\nüöÄ Î≥ÄÌôò Ï†ÅÏö© Ï§ë...');

    for (const result of changedFiles) {
      fs.writeFileSync(result.filePath, result.transformedContent, 'utf-8');
      console.log(`  ‚úÖ ${path.relative(process.cwd(), result.filePath)}`);
    }

    console.log(`\nüéâ ${changedFiles.length}Í∞ú ÌååÏùº Î≥ÄÌôò ÏôÑÎ£å!`);
  } else if (changedFiles.length === 0) {
    console.log('\n‚ú® Î≥ÄÌôòÌï† ÌååÏùºÏù¥ ÏóÜÏäµÎãàÎã§.');
  }
}

// CLI
const isDryRun = !process.argv.includes('--apply');

// Only run if directly executed (not imported as module)
if (import.meta.url === `file://${process.argv[1].replace(/\\/g, '/')}`) {
  if (isDryRun) {
    console.log('üîç DRY RUN Î™®Îìú - ÌååÏùº Î≥ÄÍ≤Ω ÏóÜÏùå');
    console.log('Ïã§Ï†ú Î≥ÄÌôòÏùÑ Ï†ÅÏö©ÌïòÎ†§Î©¥ --apply ÌîåÎûòÍ∑∏Î•º ÏÇ¨Ïö©ÌïòÏÑ∏Ïöî\n');
  }

  runCodemod(isDryRun).catch(error => {
    console.error('‚ùå Codemod Ïã§Ìñâ Ïò§Î•ò:', error);
    process.exit(1);
  });
}

// Export for testing
/**
 * @typedef {Object} Transformation
 * @property {'value-read' | 'value-write'} type
 * @property {number} line
 * @property {string} original
 * @property {string} transformed
 * @property {string} [signalName]
 * @property {string} [setterName]
 */

/**
 * @typedef {Object} TransformResult
 * @property {string} filePath
 * @property {boolean} changed
 * @property {Transformation[]} transformations
 * @property {string} [transformedContent]
 */

export { transformValueRead, transformValueWrite, analyzeFile };
